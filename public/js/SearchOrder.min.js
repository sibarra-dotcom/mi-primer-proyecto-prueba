class SearchOrder {
	static options = '';
  static selectors = '';

	static init = (selectors = [], options = []) => {

    this.options = options;
    this.selectors = selectors;
    this.tbody = document.querySelector(`#${this.selectors[0]} tbody`);
    this.orderBy = document.querySelector(`#${this.selectors[1]}`);
    this.formSearch = document.querySelector(`#${this.selectors[2]}`);

    this.initOrderBy(); 
    this.initSearchForm(); 

		this.loadPreviousSearch();
  }

  static loadPreviousSearch() {
    const savedSearch = localStorage.getItem('searchParams');

    if (savedSearch) {
      const searchParams = JSON.parse(savedSearch);
      this.applySearchParams(searchParams);
    } else {
			loadRows();
		}
  }

	static loadPreviousOrder() {
		const savedOrder = localStorage.getItem('orderBy');

		if (savedOrder) {
			this.orderBy.value = savedOrder; 
			this.reorderTableRows(savedOrder.split('-'));
		}
  }

  static loadSearchRows(e) {
		if (!e) {	console.log('Event object is undefined');  return; }

		const form = e.target;

		Service.hide('.row--empty');
		Service.stopSubmit(form, true);

		this.tbody.innerHTML = Service.loader();

		const formData = new FormData(form);

		Service.exec('post', this.selectors[3], formData_header, formData)
		.then(r => {
			renderRows(r);
			Service.stopSubmit(form, false);

			// this.loadPreviousOrder();
		});
  }

  static initOrderBy() {
		if (!this.orderBy || this.orderBy.tagName !== 'SELECT') return;

    this.orderBy.addEventListener('change', (e) => {
      const order = e.target.value;
			localStorage.setItem('orderBy', order);
			this.reorderTableRows(order.split('-'));
    });
  }

	static applySearchParams(searchParams) {
    Object.keys(searchParams).forEach(key => {
      const input = this.formSearch.querySelector(`[name=${key}]`);
      if (input) {
        input.value = searchParams[key];
      }
    });

		Service.hide('.row--empty');
		this.tbody.innerHTML = Service.loader();

		const formData = new FormData();
		Object.keys(searchParams).forEach(key => {
			formData.append(key, searchParams[key]);
		});

		Service.exec('post', this.selectors[3], formData_header, formData)
		.then(r => {
			renderRows(r);

			// this.loadPreviousOrder();
		});
  }

  static initSearchForm() {
		if (!this.formSearch || this.formSearch.tagName !== 'FORM') return;

    this.formSearch.addEventListener('submit', (e) => {
      e.preventDefault();
			const searchParams = this.getSearchParams();
			localStorage.setItem('searchParams', JSON.stringify(searchParams));

      this.loadSearchRows(e);
    });
  }

	static getSearchParams() {
    const params = {};
    const inputs = this.formSearch.querySelectorAll('input, select');
    inputs.forEach(input => {
      if (input.name) {
        params[input.name] = input.value.trim();
      }
    });
    return params;
  }

  static reorderTableRows(order) {
    const rows = Array.from(this.tbody.rows);
    
    // Get the sort direction (asc/desc) and column name from 'order'
    const direction = order[0]; // 'asc' or 'desc'
    const columnName = order[1]; // e.g., 'modelo'

    // Find the column index by matching the column name in the options array
    const columnIdx = this.options.findIndex(option => option[1] === columnName);

    if (columnIdx === -1) { console.log('Column not found:', columnName); return; }

    // Get the data type for the current column
    const dataType = this.options[columnIdx][0]; // e.g., 'string', 'int', 'date', etc.

		// Helper: parse dd-mm-yyyy -> timestamp
		const parseDMY = (str) => {
			const [day, month, year] = str.split('-').map(Number);
			return new Date(year, month - 1, day).getTime(); // month is 0-based
		};

		rows.sort((a, b) => {
			let valA, valB;

			const cellA = a.cells[columnIdx].querySelector('span')?.innerText.trim() || '';
			const cellB = b.cells[columnIdx].querySelector('span')?.innerText.trim() || '';

			if (dataType === 'string') {
				valA = cellA.toLowerCase();
				valB = cellB.toLowerCase();
			} else if (dataType === 'float' || dataType === 'int') {
				valA = parseFloat(cellA) || 0;
				valB = parseFloat(cellB) || 0;
			} else if (dataType === 'date') {
				valA = cellA ? parseDMY(cellA) : 0;
				valB = cellB ? parseDMY(cellB) : 0;
			}

			if (direction === 'asc') {
				return valA > valB ? 1 : valA < valB ? -1 : 0;
			} else {
				return valA < valB ? 1 : valA > valB ? -1 : 0;
			}
		});

    // Sort the rows based on the column data type
    // rows.sort((a, b) => {
    //   let valA, valB;

    //   // Extract the values from the cells based on the data type
    //   if (dataType === 'string') {
    //     valA = a.cells[columnIdx].querySelector('span').innerText.trim().toLowerCase();
    //     valB = b.cells[columnIdx].querySelector('span').innerText.trim().toLowerCase();
    //   } else if (dataType === 'float' || dataType === 'int') {
    //     valA = parseFloat(a.cells[columnIdx].querySelector('span').innerText);
    //     valB = parseFloat(b.cells[columnIdx].querySelector('span').innerText);
    //   } else if (dataType === 'date') {
    //     valA = new Date(a.cells[columnIdx].querySelector('span').innerText).getTime();
    //     valB = new Date(b.cells[columnIdx].querySelector('span').innerText).getTime();
    //   }

    //   // Compare values based on the sort direction
    //   if (direction === 'asc') {
    //     return valA > valB ? 1 : -1;
    //   } else {
    //     return valA < valB ? 1 : -1;
    //   }
    // });

    // Re-append sorted rows to the table
    rows.forEach(row => this.tbody.appendChild(row));
  }
}